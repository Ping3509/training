# 归并排序

归并排序是一种基于分治思想的排序算法，通过将待排序序列不断地分割成小的子序列，对每个子序列进行排序，然后将这些已经有序的子序列合并成一个有序序列。归并排序的时间复杂度为 O(nlogn)，空间复杂度为 O(n)。

归并排序通常应用于需要对大规模数据进行排序的场合，比如外部排序问题。外部排序问题是指当内存无法容纳全部待排序数据时，需要将数据分成多个小块，每次将一部分数据读入内存进行排序，最后将排好序的小块合并成一个有序序列。

归并排序的基本思想就是将待排序序列不断地分割成小的子序列，对每个子序列进行排序，然后将这些已经有序的子序列合并成一个有序序列。具体做法是将待排序序列分成两个长度相等的子序列，对每个子序列进行排序，然后将它们合并成一个有序序列。这个过程可以递归地进行，直到最终得到一个有序序列。

## 归并排序模板

```cpp
void merge_sort(vector<int>& nums, int left, int right) {
    if (left >= right) { // 如果待排序的序列只有一个或者没有元素，直接返回
        return;
    }
    int mid = left + (right - left) / 2; // 找到序列的中间位置
    merge_sort(nums, left, mid); // 对左子序列进行归并排序
    merge_sort(nums, mid + 1, right); // 对右子序列进行归并排序
    vector<int> tmp(right - left + 1); // 创建临时数组
    int i = left, j = mid + 1, k = 0; // i、j 和 k 分别指向左子序列、右子序列和临时数组中的当前元素
    while (i <= mid && j <= right) { // 将左子序列和右子序列中的元素依次取出比较，并将较小的元素存入临时数组中
        if (nums[i] <= nums[j]) {
            tmp[k++] = nums[i++];
        } else {
            tmp[k++] = nums[j++];
        }
    }
    while (i <= mid) { // 将左子序列中剩余的元素存入临时数组中
        tmp[k++] = nums[i++];
    }
    while (j <= right) { // 将右子序列中剩余的元素存入临时数组中
        tmp[k++] = nums[j++];
    }
    for (int i = left, j = 0; i <= right; i++, j++) { // 将临时数组中的元素复制回原数组中
        nums[i] = tmp[j];
    }
}
```

该算法的基本思路是将待排序序列递归地分割成左右两个子序列，然后对左右两个子序列分别进行归并排序，最后将左右两个子序列合并成一个有序序列。

在归并排序的合并阶段中，使用一个额外的数组来存储合并的结果，并使用三个指针 i、j 和 k 分别指向左子序列、右子序列和临时数组中的当前元素，比较左子序列和右子序列的当前元素的大小，并将较小的元素存入临时数组中。最后将剩余的元素依次存入临时数组中，然后再将临时数组中的元素复制回原数组中。

归并排序的时间复杂度是 O(nlogn)，其中 n 是序列的长度。