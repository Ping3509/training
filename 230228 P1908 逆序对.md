## **P1908 逆序对**

https://www.luogu.com.cn/problem/P1908

https://www.luogu.com.cn/problem/solution/P1908

归并排序

如果你想求一个序列中逆序对的个数，可以使用归并排序算法来解决这个问题。

具体的做法是在归并排序的过程中，记录逆序对的个数。在归并排序的合并阶段中，假设左右两个子序列已经有序，那么可以使用双指针的方式，分别从左到右遍历左子序列和右子序列，如果左子序列当前元素的值大于右子序列当前元素的值，那么就说明左子序列当前元素之后的所有元素都是右子序列当前元素的逆序对，因此可以累加逆序对的个数。

具体实现过程中，可以使用一个额外的数组来保存归并排序中的中间结果，这个数组可以在每次合并操作中被重复利用，从而避免了频繁的内存分配和释放。

归并排序求逆序对的时间复杂度为 O(nlogn)，其中 n 是序列的长度，因此归并排序是一个高效的求解逆序对问题的算法。

```cpp
#include <iostream>
#include <vector>

using namespace std;

// 归并排序并统计逆序对
long long merge_sort(vector<int>& nums, int left, int right) {//记得&引用
    if (left >= right) { // 如果左边界大于等于右边界，不需要再继续划分子序列
        return 0; // 返回逆序对数量为0
    }
    int mid = left + (right - left) / 2; // 计算中间位置
    long long count = merge_sort(nums, left, mid) + merge_sort(nums, mid + 1, right); // 分别对左半部分和右半部分进行递归处理，并将两者的逆序对数量相加
    vector<int> tmp(right - left + 1); // 创建临时数组
    int i = left, j = mid + 1, k = 0; // i表示左半部分数组的当前下标，j表示右半部分数组的当前下标，k表示临时数组的当前下标
    while (i <= mid && j <= right) { // 比较左半部分数组和右半部分数组中的元素
        if (nums[i] <= nums[j]) { // 如果左半部分数组中的元素小于等于右半部分数组中的元素，那么它们之间不存在逆序对
            tmp[k++] = nums[i++]; // 将左半部分数组中的元素加入到临时数组中
        } else { // 如果左半部分数组中的元素大于右半部分数组中的元素，那么它们之间存在逆序对
            count += mid - i + 1; // 统计逆序对数量
            tmp[k++] = nums[j++]; // 将右半部分数组中的元素加入到临时数组中
        }
    }
    while (i <= mid) { // 如果左半部分数组中还有元素未处理，将其加入到临时数组中
        tmp[k++] = nums[i++];
    }
    while (j <= right) { // 如果右半部分数组中还有元素未处理，将其加入到临时数组中
        tmp[k++] = nums[j++];
    }
    for (int i = left, j = 0; i <= right; i++, j++) { // 将临时数组中的元素复制到原数组中
        nums[i] = tmp[j];
    }
    return count; // 返回逆序对数量
}

int main() {
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    long long count = merge_sort(nums, 0, n - 1); // 统计逆序对数量
    cout << count << endl; // 输出逆序对数量
    return 0;
}
```

<aside>
💡

在上述代码中，我们定义了一个 **`merge_sort`** 函数，其中 **`nums`** 是一个 vector 类型的数组，它被以引用传递的方式传入函数中。函数中对 **`nums`** 的修改会直接反映到实参中。

在 **`merge_sort`** 函数中，我们首先将数组 **`nums`** 拆分成左半部分和右半部分，然后分别对左半部分和右半部分进行排序，最后合并两个有序数组，并统计左半部分数组中大于右半部分数组中元素的个数。

在合并两个有序数组时，我们使用了一个临时数组 **`temp`**，将左半部分数组和右半部分数组中的元素依次从小到大放入 **`temp`** 数组中。如果左半部分数组中的元素大于右半部分数组中的元素，那么它们之间存在逆序对，我们就可以将逆序对数量统计到 **`count`** 变量中。

如果不使用引用，那么在 **`merge_sort`**函数中对 **`nums`**
 的修改并不会影响到 **`main`**函数中的 **`nums`**
，也就是说，排序后的结果并没有被正确地返回。因此需要使用引用，将 **`nums`**
 的地址传递到 **`merge_sort`**函数中，这样就能够正确地修改 **`nums`**的值并返回排序后的结果了。

</aside>

注意用longlong不然会爆

如果左半部分数组中的元素小于等于右半部分数组中的元素，那么它们之间不存在逆序对

// 如果左半部分数组中的元素大于右半部分数组中的元素，那么它们之间存在逆序对

当左半部分数组中的元素 $nums[i]$ 大于右半部分数组中的元素 $nums[j]$ 时，它们之间存在逆序对。因为此时左半部分数组中 $i$ 右侧的所有元素都大于 $nums[j]$，而 $j$ 左侧的所有元素都小于 $nums[i]$，所以这些元素都和 $nums[j]$ 组成逆序对。

具体来说，左半部分数组中从 $i$ 到 $mid$ 的元素都大于 $nums[j]$，因此有 $mid-i+1$ 个元素和 $nums[j]$ 组成逆序对。这就是为什么在归并排序中统计逆序对数量时要加上 $mid-i+1$ 的原因。

//记得&引用

在 C++ 中，函数参数传递有两种方式：值传递和引用传递。当以值传递的方式调用函数时，实参的值会被复制到形参中，函数体内对形参的修改不会影响实参的值。

而当以引用传递的方式调用函数时，实参的地址被传递到形参中，函数内对形参的修改会直接反映到实参中。

对于归并排序，我们希望在合并两个有序子数组的过程中，直接修改原始的数组 $nums$。因此，我们需要使用引用传递来避免数组的复制。

如果没有使用引用传递，而是以值传递的方式传递数组 $nums$，那么在递归调用的过程中，每次合并两个有序子数组都需要复制一遍数组，这样不仅浪费内存空间，而且会导致算法运行时间变长，影响算法效率。