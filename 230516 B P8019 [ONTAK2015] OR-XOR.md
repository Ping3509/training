# B **P8019 [ONTAK2015] OR-XOR**

**P8019 [ONTAK2015] OR-XOR**

[BZOJ4245 ONTAK2015 OR-XOR 【位运算+贪心】*_weixin_30512043的博客-CSDN博客](https://blog.csdn.net/weixin_30512043/article/details/99470759)

主要用了上面的，位运算，贪心，前缀和

[[ONTAK2015] OR-XOR - 洛谷](https://www.luogu.com.cn/problem/P8019?contestId=109920)

使用位运算：异或运算和按位或运算可以通过位运算来实现，这样可以提高计算效率。对于异或运算，可以使用位异或（^）操作符；对于按位或运算，可以使用位或（|）操作符。

```
#include<bits/stdc++.h>
using namespace std;
#define N 500010
#define LL long long
#define id (1ll<<i)
#define fu(a,b,c) for(LL a=b;a<=c;++a)
#define fd(a,b,c) for(LL a=b;a>=c;--a)

LL a[N], n, m;
bool vis[N] = {0};

int main() {
    scanf("%lld%lld", &n, &m);

    // 读入数组a并计算前缀异或和
    fu(i, 1, n) {
        scanf("%lld", &a[i]);
        a[i] ^= a[i - 1];
    }

    LL ans = 0;

    // 从第63位开始逐位处理
    fd(i, 63, 0) {
        // 如果数组a的最后一个元素在当前位上为1，直接将当前位加入到答案中
        if (a[n] & id) {
            ans |= id;
            continue;
        }

        int siz = 0;
        // 统计在当前位上为0且尚未被标记的元素个数
        fu(j, 1, n) {
            if (!vis[j] && !(a[j] & id)) {
                siz++;
            }
        }

        // 如果个数小于m，则将当前位加入到答案中
        if (siz < m) {
            ans |= id;
        } else {
            // 将当前位上为1的元素标记为已访问
            fu(j, 1, n) {
                if (a[j] & id) {
                    vis[j] = 1;
                }
            }
        }
    }

    printf("%lld", ans);
    return 0;
}

```

这段代码的主要思路是通过位运算和贪心的策略找出使得总费用最小的方案。

具体解释如下：

1. 在代码的开头定义了一些常量和宏，以便更方便地编写代码。
2. 读入变量n和m，表示数组长度和划分的段数。
3. 使用前缀异或和计算数组a。
4. 初始化答案ans为0。
5. 从第63位开始逐位处理（i从63递减到0）。
6. 如果数组a的最后一个元素在当前位上为1，将当前位加入到答案中（ans按位或id）。
7. 否则，统计在当前位上为0且尚未被标记的元素个数，如果个数小于m，则将当前位加入到答案中。
8. 如果个数不小于m，则将当前位上为1的元素标记为已访问。
9. 输出最终的答案ans。

希望这个分析和注释能够更容易理解代码的逻辑和算法思路。如果还有任何疑问，请随时提问。

以下是使用C++编写的完整解法，附有详细注释：

这段代码使用了循环和位运算的方式来解决问题。通过逐位处理数组元素，统计每一位上为1的元素个数，然后根据个数的奇偶性进行相应的操作和判断。

代码中使用了一些辅助变量和数组，包括`ans`用于存储最终结果，`xp`数组用于记录中间结果，`tot`记录满足条件的段的数量。

[P8019 [ONTAK2015] OR-XOR - HpyX の 小窝 - 洛谷博客 (luogu.com.cn)](https://www.luogu.com.cn/blog/291706/solution-p8019)

- 使用了位运算和迭代的方式来求解该问题。下面对代码进行解释：
    
    ```
    for(ll now_pos = 1ll << 62; now_pos; now_pos >>= 1)
    
    ```
    
    该循环是一个迭代的过程，从最高位开始迭代到最低位。`now_pos`是当前迭代的位置，初始值为`1ll << 62`，每次迭代右移一位。
    
    ```
    for(sum = 0, tmp = 1; tmp <= n; tmp++)
        sum += (val[tmp] & now_pos) > 0;
    
    ```
    
    在每一次迭代中，计算在当前位置`now_pos`下，原数组`val`中有多少个元素的该位置上的位为1，将结果累加到`sum`中。
    
    ```
    if(sum & 1) ans ^= now_pos;
    
    ```
    
    如果`sum`是奇数，即当前位置`now_pos`上1的个数为奇数，将`now_pos`与`ans`进行异或操作。
    
    ```
    else
    {
        // ...
    }
    
    ```
    
    如果`sum`是偶数，即当前位置`now_pos`上1的个数为偶数，则进入`else`分支。
    
    ```
    for(flag = sum = 0, tmp = 1; tmp < n; tmp++)
    {
        flag ^= (val[tmp] & now_pos);
        xp[tmp] += flag, sum += (xp[tmp] == 1) & flag;
    }
    
    ```
    
    在该分支中，对于数组`val`的每个元素，将其与`now_pos`进行位与操作，然后将结果与`flag`进行异或操作。同时，更新数组`xp`的值，以及计算满足条件`(xp[tmp] == 1) & flag`的元素个数，并将结果累加到`sum`中。
    
    ```
    if(sum + tot + m > n)
    {
        ans ^= now_pos;
        for(flag = sum = 0, tmp = 1; tmp < n; tmp++)
        {
            flag ^= (val[tmp] & now_pos);
            xp[tmp] -= flag;
        }
    }
    else tot += sum;
    
    ```
    
    如果`sum`加上之前的累计值`tot`和`m`大于`n`，即满足划分条件，则将`now_pos`与`ans`进行异或操作，并将之前更新的`xp`值进行恢复。否则，将`sum`累加到`tot`中。
    
    ```
    printf("%lld\\n", ans);
    
    ```
    
    最后，输出最终的结果`ans`。
    
    这种解法利用了位运算的性质，通过统计每个位置上1的个数的奇偶性来进行判断和操作。它的时间复杂度较低，是一种较为高效的解法。
    

### 为什么是62

在给定的代码中，迭代的起始位置是`1ll << 62`，也就是从最高位的第63位开始迭代。这是因为使用的是64位长整型(`ll`表示长整型)。对于64位长整型数，最高位是第63位，最低位是第0位。

使用`1ll << 62`作为起始位置，是为了从最高位开始遍历，依次处理每一位的情况。由于给定的数组元素范围为0到10^18，可以使用64位长整型来保证可以表示所有可能的位。

需要注意的是，这个解法假设了`long long`是64位的。在不同的环境中，`long long`可能是不同的位数，因此需要根据具体环境和数据范围进行调整。

### 1LL

`1ll`是一个整数字面值，表示一个`long long`类型的整数常量。

在C++中，整数字面值默认是`int`类型的。然而，在某些情况下，我们可能需要使用更大范围的整数类型，比如`long long`。为了确保整数字面值被解释为`long long`类型，我们可以在数字面值后面添加`ll`后缀，表示这是一个`long long`类型的整数常量。

`1ll`的作用是将数字1表示为`long long`类型，以便与后续的位运算或其他操作兼容。在给定的代码中，使用`1ll << 62`来创建一个`long long`类型的值，左移62位，用于表示最高位开始的迭代位置。

您是正确的，左移操作确实是将一个数乘以2的幂。在给定的代码中，使用`1ll << 62`左移62位，实际上是将数字1左移62位，相当于乘以2的62次方。

然而，在位运算中，我们通常使用从0开始的位索引。对于64位的整数，最高位的索引是63，最低位的索引是0。因此，在这种情况下，将数字1左移62位实际上是将其移动到最高位上（第63位），而不是第62位。

因此，在这段代码中，使用`1ll << 62`来表示从最高位（第63位）开始的迭代位置。这样可以确保从最高位开始遍历每一位的情况。

`1LL`和`2LL`是在C++中表示`long long`类型的整数常量。**`1LL`**来表示一个**`long long`**类型的数字1，而不仅仅是**`int`**类型的数字1。同样，**`2LL`**表示**`long long`**类型的数字2。

在C++中，整数字面值默认是`int`类型的。然而，有时我们可能需要使用更大范围的整数类型，比如`long long`。为了确保整数字面值被解释为`long long`类型，我们可以在数字面值后面添加`LL`后缀，表示这是一个`long long`类型的整数常量。

`1LL`表示数字1的`long long`类型常量，`2LL`表示数字2的`long long`类型常量。通过使用`LL`后缀，我们可以确保这些常量被解释为`long long`类型，而不是默认的`int`类型。这在需要使用大整数范围的场景中是很有用的。